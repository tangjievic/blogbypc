<!DOCTYPE html>
<html>
<!-- head模块设置[[ -->
<%= require('html-loader!../../components/elements/head/index.html') %>
    <!-- head模块设置]] -->

    <body class="wetui-page">
        <div class="tjblog-page__box">
            <div class="view">
                <%= require('html-loader!../../components/wetui/base/leftmenu/index.html')%>
                <%= require('html-loader!../../components/wetui/base/headernav/index.html')%>
                <div class="view_right">
                    <div class="blog_art-content">
                        <header class="right_content-hd">
                            <div class="hd_title tag_title">主标题·副标题</div>
                            <%= require('html-loader!../../components/elements/bubbleline/index.html') %>
                            <div class="tags_box">
                                <span class="wet-tag wet-tag__sm wet-tag__primary">公众文章</span>
                                <span class="wet-tag wet-tag__sm wet-tag__success">普通文章</span>
                                <span class="wet-tag wet-tag__sm wet-tag__warn">vip文章</span>
                                <span class="wet-tag wet-tag__sm wet-tag__risk">前端大杂烩</span>
                                <span class="wet-tag wet-tag__sm wet-tag__info">HTML5/CSS3</span>
                            </div>
                        </header>
                        <div class="art_msg">
                            <span>
                                <i class="iconfont icon-icon-awsauthor"></i>作者：TANGJIE               
                            </span>
                            <span>
                                <i class="iconfont icon-fire"></i>查看：5                    
                            </span>
                            <span>
                                <i class="iconfont icon-friend"></i>发布时间：2019-01-31                   
                            </span>
                        </div>
                        <div class="art_desc">
                            简介：本部分主要是介绍数据结构和算法的基本概念，尤其是讲解了时间复杂度，提及了空间复杂度。
                        </div>
                        <div class="art_deline"></div>
                        <article data-toc="#toc" class="article markdown-body">
                            <h3 id="toc-heading-1"><a id="React_Hook_useEffect_0"></a>React Hook：使用 useEffect</h3>
    <h4 id="toc-heading-2"><a id="1_1"></a>1.描述</h4>
    <p>数据获取，设置订阅或者手动直接更改 React 组件中的 DOM 都属于副作用。有的人习惯成这种行为为 effects，我是比较习惯叫 side effects 也就是副作用的， 这是个概念，需要在 React 必须习惯的概念。</p>
    <p>如果熟悉 React 类声明周期方法，可以把 useEffect Hook 视作 componentDidMount、componentDidUpdate 和 componentWillUnmount 的组合体。</p>
    <p>React 组件中有两种常见的副作用：</p>
    <ul>
    <li>a.需要清理的副作用。</li>
    <li>b.不需要清理的副作用。</li>
    </ul>
    <h4 id="toc-heading-3"><a id="2_11"></a>2.需要清理的副作用</h4>
    <p>有的时候，我们希望在 React 更新 DOM 之后进行一些额外的操作。网络请求、手动更改 DOM 以及日志记录都是不需要清理的副作用的常见场景。因为运行之后，可以立即被销毁掉。</p>
    <h5 id="toc-heading-4"><a id="21__class__13"></a>2.1 在 class 组件中</h5>
    <p>下面是在 class 组件和 function 组件中分别表示这两种副作用的使用方式</p>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
    };
    }

    componentDidMount() {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.count}</span> times`</span>;
    }

    componentDidUpdate() {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.count}</span> times`</span>;
    }

    render() {
    <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {this.state.count} times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.setState({ count: this.state.count + 1 })}&gt;
    Click me
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
    }
    }
    </code></div></pre>
    <p>上面代码很明显，class 组件中，两个生命周期中有相同的代码（虽然 componentDidUpdate 中的内容也可以放在 click 的事件 handler 中）</p>
    <p>这是因为在多数情况下，我们希望执行相同的副作用，无论是组件刚 mount 还是 update 之后。而从概念上来讲，我们希望他在每次 render 之后发生，但是 React 类组件是没有这种生命周期的。虽然可以把 document.title = ‘You clicked’ + this.state.count + ’ times’; 这个操作封装到一个方法中，但是还是需要在 componentDidMount 和 componentDidUpdate 中调用两次。</p>
    <h5 id="toc-heading-5"><a id="22__effect_Hook__48"></a>2.2 使用 effect Hook 的示例</h5>
    <pre><div class="hljs"><code class="lang-JavaScript">mport { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);

    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;
    });

    <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {count} times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
    Click me
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
    }
    </code></div></pre>
    <h6 id="toc-heading-6"><a id="221_useEffect__69"></a>2.2.1 useEffect 做了什么？</h6>
    <p>通过使用这个 Hook，通知 React 组件需要在渲染后执行什么操作。React 将记住传递的 function（把这个 function 成为 “effect”），并在执行 DOM 更新后调用这个 function。在这个效果中，主要的功能仍旧是设置 document.title,但是也可以执行数据获取，或者是调用其他的命令式的 API。</p>
    <h6 id="toc-heading-7"><a id="222__useEffect_71"></a>2.2.2 为什么在组件内调用 useEffect？</h6>
    <p>在组件内使用 useEffect 是的可以直接从副作用中访问计数器的 count 或者任何的 props。不需要使用特殊的 API 来读取它，它已经在函数的范围内了（通过 useState）。Hooks 拥抱 Javascript 的闭包，并且避免在 Javascript 已经提供解决方案的情况下在去引入特定的 React API。</p>
    <h6 id="toc-heading-8"><a id="223__render__useEffect__73"></a>2.2.3 每次 render 之后都会执行 useEffect 吗？</h6>
    <p>【是的】这是默认行为，在第一次 render 之后和每次 update 之后都会运行。你可能会更容易的认为副作用发生在 “render 之后”，而不是发生在 “mount” 和 “update” 之后。不过 React 保证 DOM 在运行时副作用已经更新。（网络请求每次都放在这里面肯定是有问题的，因此需要定制）如果要定制 useEffect 的默认执行行为，可以参考：<a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank">https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects</a></p>
    <h6 id="toc-heading-9"><a id="224__76"></a>2.2.4 详细代码拆分说明</h6>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);

    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;
    });
    }
    </code></div></pre>
    <p>我们通过 useState 声明了 count state 变量，并且通知 React 需要使用 effect。</p>
    <p>然后把一个 funcrion 传递给 useEffect Hook，而传递的这个 funcrion 就是副作用。</p>
    <p>在我们的副作用中，使用 document.title 浏览器 API 设置文档的标题，可以在 effect 中读取最新的 count，因为 count 变量作用域就是在整个 Example function 中。当 React 渲染我们的组件时，会机主我们使用的 effect，然后在更新 DOM 后运行需要的下沟哦。每次渲染都会发生这样的情况，包括第一次 render。</p>
    <p>你可能会注意到，传递给 useEffect 的 function 在每次 render 的时候有所不同，这是故意为之的。事实上，这就是让我们在副作用中读取 count 值而不需要担心这个值是旧值。每次在 re-render 的时候，都会有一个不同的副作用，来取代之前的副作用。在某种程度上，这使得副作用更像是 render 结果的一部分——每个副作用都“属于”特殊的 render。文章后面会提到为什么这是有用的。</p>
    <p>【注意】</p>
    <p>与 <mark>componentDidMount</mark> 和 componentDidUpdate 不同，使用 useEffect 调度的副作用不会阻塞浏览器更新屏幕。这使得 application 感觉上具有响应式。大多数副作用不需要同步发生。而如果需要同步进行，（比如测量布局），有一个单独的 useLayoutEffect Hook， API 和 useEffect 相同。</p>
    <h5 id="toc-heading-10"><a id="3__97"></a>3. 需要清理的副作用</h5>
    <p>上面都是不需要清理的副作用，然而，有些副作用是需要去清理的。比如，肯呢过希望设置对某些外部数据源的 subscription。而在这种情况下，清理订阅是非常重要的，这样不会引入内存泄露。</p>
    <h6 id="toc-heading-11"><a id="31__class__100"></a>3.1 使用 class 组件示例：</h6>
    <p>在 React class 中，通常会在 componentDidMount 中设置帝国与，而在 componentWillUnmount 中清楚它。比如有一个 ChatAPI 模块，可以订阅好友的在线状态，在 class 组件中可能如下所示：</p>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriendStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">isOnline</span>: <span class="hljs-literal">null</span> };
    <span class="hljs-keyword">this</span>.handleStatusChange = <span class="hljs-keyword">this</span>.handleStatusChange.bind(<span class="hljs-keyword">this</span>);
    }

    componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    handleStatusChange(status) {
    <span class="hljs-keyword">this</span>.setState({
    <span class="hljs-attr">isOnline</span>: status.isOnline
    });
    }

    render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.isOnline === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Loading...'</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.isOnline ? <span class="hljs-string">'Online'</span> : <span class="hljs-string">'Offline'</span>;
    }
    </code></div></pre>
    <p>请注意 componentDidMount 和 componentWillMount 需要相互对应。class 组件的生命周期强制我们去拆分这个逻辑，即使他们中的概念代码和相同的副作用是有关的。</p>
    <p>眼力好的人可能注意到了上面的示例可能需要一个 componentDidUpdate 才能完全的正确，目前暂时忽略。</p>
    <h6 id="toc-heading-12"><a id="32_Hooks__141"></a>3.2使用 Hooks 的示例</h6>
    <p>一开始，可能会认为需要单独的 effect 去清理，但是添加订阅和删除订阅的代码联系非常紧密，因此 useEffect 旨在将它保持在一起。如果你的副作用返回一个方法，则 React 则在清理时运行</p>
    <pre><div class="hljs"><code class="lang-JavaScript">mport { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendStatus</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = useState(<span class="hljs-literal">null</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>) </span>{
    setIsOnline(status.isOnline);
    }

    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    <span class="hljs-comment">// Specify how to clean up after this effect:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>) </span>{
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
    });

    <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Loading...'</span>;
    }
    <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">'Online'</span> : <span class="hljs-string">'Offline'</span>;
    }
    </code></div></pre>
    <p>a、为什么从 effect 中返回一个 function？<br>
    这是 effect 可选的清理机制。每个 effect 都可以返回一个在它之后清理的 function。这使得我们能够保持添加订阅和删除订阅彼此接近的订阅的逻辑。这同样是 effect 的一部分。</p>
    <p>b、React 在什么时候清理？<br>
    当组件卸载的时候，React 会执行清理工作。</p>
    <p>然而，effect 会针对每个 render 运行而不仅仅是一次，这就是 React 在下次运行 effect 之前还清除前一个 render effect 的原因。</p>
    <p>有两个链接：</p>
    <p><a href="https://reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update" target="_blank">为什么上述行为能够避免 bug</a><br>
    <a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank">如何在出现性能问题时选择退出此行为</a></p>
    <h5 id="toc-heading-13"><a id="4_179"></a>4.总结</h5>
    <p>已经了解了 useEffect 能够在组件 render 之后进行不同类型的副作用。某些 effect 可能需要清理，因此可以在 effect 中返回一个 function</p>
    <pre><div class="hljs"><code class="lang-JavaScript"> useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
    });
    </code></div></pre>
    <p>而有一些 side effect 可能没有清理的过程，因此不需要返回任何内容。</p>
    <pre><div class="hljs"><code class="lang-JavaScript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;
    });
    </code></div></pre>
    <p>通过 <mark>useEffect</mark>，能够将之前在两个生命周期中的内容整合到一个 function 中。</p>
    <h4 id="toc-heading-14"><a id="5__useEffect__tips_197"></a>5. 使用 useEffect 的 tips</h4>
    <h5 id="toc-heading-15"><a id="51_Tips_useEffect__198"></a>5.1 Tips：使用多个 useEffect 来分离问题</h5>
    <p>使用 Hook 的动机中包括了 class 组件的生命周期将相关的逻辑拆分的问题的解决，而在 Hook 的使用中，也能够把多个 effect 放在 function 组件</p>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriendStatusWithCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">isOnline</span>: <span class="hljs-literal">null</span> };
    <span class="hljs-keyword">this</span>.handleStatusChange = <span class="hljs-keyword">this</span>.handleStatusChange.bind(<span class="hljs-keyword">this</span>);
    }

    componentDidMount() {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.count}</span> times`</span>;
    ChatAPI.subscribeToFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    componentDidUpdate() {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.count}</span> times`</span>;
    }

    componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    handleStatusChange(status) {
    <span class="hljs-keyword">this</span>.setState({
    <span class="hljs-attr">isOnline</span>: status.isOnline
    });
    }
    </code></div></pre>
    <p>请注意设置 document.title 的逻辑如何在 componentDidMount 和 componentDidUpdate 之前拆分。而订阅的逻辑也在 componentDidMount 和 componentDidUpdate 之间传播。componentDidMount 包含两个任务的代码。</p>
    <p>使用 Hook 解决这个问题其实就像之前使用 useState 解决问题一样，可以使用多个 effect，然后将不相关的逻辑都拆分成不同的 effect。</p>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendStatusWithCounter</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);
    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;
    });

    <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = useState(<span class="hljs-literal">null</span>);
    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>) </span>{
    setIsOnline(status.isOnline);
    }
    <span class="hljs-comment">// ...</span>
    }
    </code></div></pre>
    <p>Hooks 允许我们根据它正在做的事情而不是生命周期方法名称来拆分代码。React 将按照指定的顺序应用组件使用的每个 effect。</p>
    <h5 id="toc-heading-16"><a id="52__effect__update__258"></a>5.2 说明：为什么 effect 在每次 update 都会运行</h5>
    <p>如果你习惯了使用 class 组件，你可能想知道为什么每次 re-render 之后，effect 的清理都会执行，而不是在卸载过程中只执行一次（打断点就能知道）。</p>
    <p>在 useState 的文章<a href="http://www.ptbird.cn/react-hook-use-state-hook.html" target="_blank">http://www.ptbird.cn/react-hook-use-state-hook.html</a> 中有一个 FriendStatus 来表示好友是否在线，class 组件冲 this.props 中读取 friend.id，在组件 mount 之后，就订阅朋友的状态，并在卸载期间取消订阅：</p>
    <pre><div class="hljs"><code class="lang-JavaScript">componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }
    </code></div></pre>
    <p>但是如果 friend prop 在组件出现在屏幕上时发生了和变化，又会发生什么呢？类组件将继续显示不同的朋友的在线状态，这是一个bug，并且因为取消订阅使用了错误的 friend ID，卸载时还可能导致内存泄露或崩溃。</p>
    <p>因此在类组件中，需要添加 componentDidUpdate 来处理这种情况：</p>
    <pre><div class="hljs"><code class="lang-JavaScript">componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    componentDidUpdate(prevProps) {
    <span class="hljs-comment">// Unsubscribe from the previous friend.id</span>
    ChatAPI.unsubscribeFromFriendStatus(
    prevProps.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    <span class="hljs-comment">// Subscribe to the next friend.id</span>
    ChatAPI.subscribeToFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }

    componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
    <span class="hljs-keyword">this</span>.props.friend.id,
    <span class="hljs-keyword">this</span>.handleStatusChange
    );
    }
    </code></div></pre>
    <p>忘记处理 componentDidUpdate 是 React 应用程序中常见的错误。</p>
    <p>如果使用 Hook ：</p>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendStatus</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-comment">// ...</span>
    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
    });
    </code></div></pre>
    <p>上面的代码如果 this.props.friend 发生了变化，也不会受到影响。</p>
    <p>没有用于处理 update 的特殊的代码，因为默认情况下 useEffect 会处理它们。它们在应用下一个 effect 之前清楚之前的 effect。为了说明这一点，下面是一个订阅和取消订阅调用的序列，这个组件可能随着时间的推移产生：</p>
    <pre><div class="hljs"><code class="lang-JavaScript"><span class="hljs-comment">// Mount with { friend: { id: 100 } } props</span>
    ChatAPI.subscribeToFriendStatus(<span class="hljs-number">100</span>, handleStatusChange);     <span class="hljs-comment">// Run first effect</span>

    <span class="hljs-comment">// Update with { friend: { id: 200 } } props</span>
    ChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">100</span>, handleStatusChange); <span class="hljs-comment">// Clean up previous effect</span>
    ChatAPI.subscribeToFriendStatus(<span class="hljs-number">200</span>, handleStatusChange);     <span class="hljs-comment">// Run next effect</span>

    <span class="hljs-comment">// Update with { friend: { id: 300 } } props</span>
    ChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">200</span>, handleStatusChange); <span class="hljs-comment">// Clean up previous effect</span>
    ChatAPI.subscribeToFriendStatus(<span class="hljs-number">300</span>, handleStatusChange);     <span class="hljs-comment">// Run next effect</span>

    <span class="hljs-comment">// Unmount</span>
    ChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">300</span>, handleStatusChange); <span class="hljs-comment">// Clean up last effect</span>
    </code></div></pre>
    <p>这种默认行为确保了一致性，并防止由于缺少 update 的处理逻辑而产生 class 组件中常见的错误。</p>
    <h5 id="toc-heading-17"><a id="53_Tip_effect__342"></a>5.3 Tip：跳过 effect 优化性能</h5>
    <p>在某些情况下，每次 render 后清理或者使用 effect 可能会产生性能问题。在类组件中，可以通过 componentDidUpdate 中编写 prevProps 或 prevState 的额外比较来解决这个问题：</p>
    <pre><div class="hljs"><code class="lang-JavaScript">componentDidUpdate(prevProps, prevState) {
    <span class="hljs-keyword">if</span> (prevState.count !== <span class="hljs-keyword">this</span>.state.count) {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.count}</span> times`</span>;
    }
    }
    </code></div></pre>
    <p>这个要求很常见，而这种方式已经被内置到 useEffect Hook 的 API中，如果在重新渲染之间没有更新某些值，则可以告诉 React 跳过 effect，为了实现这种方式，需要将数组作为可选的第二个参数传递给 useEffect：</p>
    <pre><div class="hljs"><code class="lang-JavaScript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;
    }, [count]);<span class="hljs-comment">// 只有在 count 发生变化的时候才会执行这个 effect</span>
    </code></div></pre>
    <p>上面的例子中， [count] 作为第二个参数传递。如果 count = 5，然后组件如果进行了 re-render，如果 count=5，则 React 会比较前一个 render 和 下一个 render 的值。因为两次 5 === 5，因此React 会跳过这次 effect，这是性能优化。</p>
    <p>当 count = 6 的时候，React 会比较 5 !== 6。此时，React 会重新去调用 effect，如果数组中有多个项目，只要有一个的比较值是不相同的， React 也会执行这个 effect。</p>
    <p>上面的作用，也同样应用于 cleanup 的 effect：</p>
    <pre><div class="hljs"><code class="lang-JavaScript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
    }, [props.friend.id]); <span class="hljs-comment">// 只有 props.friend.id 变化的时候才会调用 effect</span>
    </code></div></pre>
    <p>未来，第二个参数可能会通过构建的时候，转换自动添加。</p>
    <p>【注意】如果使用此优化，需要确保数组包含外部作用域随时间变化且 effect 使用的任何值。否则，你的代码将引用之前渲染的旧值。在 [https://reactjs.org/docs/hooks-reference.html]https://reactjs.org/docs/hooks-reference.html 有又关于 Hooks 优化的更多内容。</p>
    <p>如果要运行效果并且仅将其清理一次（在 mount 和 unmount 的时候），可以把空数组 [] 作为第二个参数传递。这告诉React你的效果不依赖于来自props或state的任何值，所以它永远不需要重新运行。这不会作为特殊情况进行处理 - 它直接遵循输入数组的工作方式。虽然传递 [] 更接近 componentDidMount 和 componentWillUnmount 的模式，但是不建议将其作为一种习惯，如果存在订阅的话，经常会导致错误。</p>
    <p>不要忘记 React 会延迟运行 useEffect 直到浏览器 render 之后，所以进行额外的操作也不是问题。</p>
                        </article>
                        <%= require('html-loader!../../components/elements/bubbleline/index.html') %>
                        <div class="css_adbox">

                        </div>
                    </div>
                    <div class="art_comment-box">
                        <h4 class="art_title">文章评论</h4>
                        <%= require('html-loader!../../components/elements/bubbleline/index.html') %>
                        <div class="pl_box"><textarea type="text" id="artcomment_input"></textarea></div>
                        <div class="btn-right">
                            <button class="wet-btn wet-submit_comment" data-aid="3">提交评论</button>
                        </div>
                        <%= require('html-loader!../../components/elements/bubbleline/index.html') %>
                        <h4 class="art_title">历史评论</h4>
                        <%= require('html-loader!../../components/elements/bubbleline/index.html') %>
                        <ul class="art_recoment">
                            <li>
                                <div class="recoment">
                                    <div class="user">
                                        <span class="name">游客:</span>
                                        <span class="wet-tag wet-tag__success wet-tag__sm">普通用户</span>
                                    </div>
                                    <div class="recoment_content">很实用，赞一个按揭房阿双方均按理说房价链接阿里发拉升发动机零售价分离的独家●■√♠♠aflka煞风景路撒地方开讲啦疯狂拉好地方咖啡咖啡咖啡喝口水都浪费抗衰老的发挥卡拉水电费卡上的符号卡机法兰克福打上来就很烦啦★★★★★◀◀◁♠☝▅▅▌▓▍▊✘☑▶♦☞☛♥♥♡♠咖啡壶 纱礼服和阿斯蒂芬</div>
                                </div>
                                <span class="recoment-time">2018/12/23</span>
                            </li>
                        </ul>
                        <div style="text-align: center;padding:15px 15px 0 15px;">
                            <svg t="1589263572512" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5639" width="200" height="200"><path d="M990.349848 711.657567l-52.804853-52.804854c-0.69026-0.69026-1.035389-1.725649-0.69026-2.761038 7.247725-32.442198 11.044152-65.229525 11.044153-97.671722 0-243.661611-197.759353-441.766094-441.075834-441.766094-67.645433 0-132.529828 14.84058-192.582407 44.176609-0.34513 0.34513-1.035389 0.34513-1.380519 0.34513-0.69026 0-1.725649-0.34513-2.070778-1.035389L266.26761 115.9636c-1.035389-1.035389-3.451298-1.725649-5.522076-1.725649-2.415908 0-4.831817 0.69026-6.212335 2.070778-2.761038 2.761038-2.761038 8.628244 0.345129 11.389282l44.866869 44.866869c5.867206 5.867206 8.973374 13.80519 8.973374 22.088305 0 8.283114-3.106168 16.221099-8.973374 22.088305-5.867206 5.867206-13.80519 8.973374-22.088305 8.973373-8.283114 0-16.221099-3.106168-22.088304-8.973373l-13.805191-13.805191c-0.34513-0.34513-0.69026-0.34513-0.690259-0.690259L201.038086 162.210988c-6.212336-6.212336-14.49545-9.663633-23.813954-9.663634s-17.946748 3.451298-24.504213 10.008763c-6.212336 6.212336-10.008763 15.185709-10.353893 24.504213-0.34513 9.318504 3.106168 17.946748 9.318504 24.159084l35.893495 36.238624c0.34513 0.34513 1.035389 0.69026 1.380519 1.380519l5.867206 5.867206c15.530839 15.530839 15.530839 40.725312 0 56.256151l-2.761038 2.761038c-7.592855 7.592855-17.601618 11.734412-28.300641 11.734412-10.699023 0-20.362656-4.141557-27.95551-11.389282-0.69026-0.34513-1.380519-0.69026-1.725649-1.380519v-0.34513l-33.477587-33.477586c-7.937984-7.937984-18.637007-12.079542-30.371419-12.079542-13.114931 0-25.539602 5.176946-34.512976 14.15032-17.601618 17.601618-17.601618 45.902258 0 63.503876l56.256151 56.601281c0.69026 0.69026 1.035389 2.070779 0.69026 3.106168-18.291877 49.353556-27.610381 101.46815-27.610381 154.273003 0 143.91911 69.025952 272.307381 176.016178 352.722615h530.119312c22.433434-16.911358 43.48635-35.893495 62.813617-57.29154 0.69026-0.69026 1.380519-1.035389 2.070778-1.035389 0.69026 0 1.725649 0.34513 2.070779 1.035389l10.699022 10.699023c8.628244 8.628244 19.672396 13.114931 31.751938 13.11493s23.123694-4.831817 31.751938-13.11493c8.628244-8.628244 13.114931-20.017526 13.460061-32.097068 0-12.424671-4.486687-23.813953-12.769801-32.097068l-21.398045-21.398045-1.03539-1.035389-48.663296-48.663297c-4.486687-4.486687-7.247725-10.699023-7.247725-17.256488s2.415908-12.769801 7.247725-17.256488c4.486687-4.486687 10.699023-7.247725 17.256488-7.247725s12.769801 2.415908 17.256488 7.247725l38.999663 38.999663 0.34513 0.34513 25.884732 25.884732c6.212336 6.212336 14.84058 9.663633 23.813954 9.663633 9.318504 0 17.946748-3.451298 24.159083-10.008763 13.80519-13.460061 13.80519-34.858106 0.690259-47.973036z" fill="#FCEFF0" p-id="5640"></path><path d="M650.742164 0c-11.389282 0-20.362656 8.973374-20.362656 20.362656 0 11.389282 8.973374 20.362656 20.362656 20.362656 11.389282 0 20.362656-8.973374 20.362656-20.362656 0-11.389282-9.318504-20.362656-20.362656-20.362656z m178.086956 68.335693h-15.530839v-15.18571c0-0.69026-0.69026-1.380519-1.380519-1.380519h-10.353893c-0.69026 0-1.380519 0.69026-1.380519 1.380519v15.18571h-15.530839c-0.69026 0-1.380519 0.69026-1.380519 1.380519v10.353892c0 0.69026 0.69026 1.380519 1.380519 1.38052h15.530839V96.636333c0 0.69026 0.69026 1.380519 1.380519 1.380519h10.353893c0.69026 0 1.380519-0.69026 1.380519-1.380519v-15.185709h15.530839c0.69026 0 1.380519-0.69026 1.380519-1.38052v-10.353892c0-0.69026-0.69026-1.380519-1.380519-1.380519zM463.681834 19.672396h-12.769802V6.557465c0-0.69026-0.69026-1.380519-1.380519-1.380519h-8.628244c-0.69026 0-1.380519 0.69026-1.380519 1.380519v12.769802h-12.769801c-0.69026 0-1.380519 0.69026-1.380519 1.380519v8.628244c0 0.69026 0.69026 1.380519 1.380519 1.380519h12.769801v12.769801c0 0.69026 0.69026 1.380519 1.380519 1.380519h8.628244c0.69026 0 1.380519-0.69026 1.380519-1.380519V30.716549h12.769802c0.69026 0 1.380519-0.69026 1.380519-1.380519V20.707786c0-0.69026-0.69026-1.035389-1.380519-1.03539zM801.908999 587.065723c-13.460061 0-24.504213 11.044152-24.504213 24.504213 0 13.460061 11.044152 24.504213 24.504213 24.504213 13.460061 0 24.504213-11.044152 24.504213-24.504213-0.34513-13.80519-11.044152-24.504213-24.504213-24.504213z m0 42.79609c-10.353893 0-18.637007-8.283114-18.637007-18.637007s8.283114-18.637007 18.637007-18.637007c10.353893 0 18.637007 8.283114 18.637007 18.637007s-8.628244 18.637007-18.637007 18.637007zM251.77216 398.279744c-10.353893 0-18.982137 8.628244-18.982136 18.982137 0 10.699023 8.628244 18.982137 18.982136 18.982137s18.982137-8.628244 18.982137-18.982137c0.34513-10.353893-8.283114-18.982137-18.982137-18.982137z m0 32.442197c-7.247725 0-13.114931-5.867206-13.11493-13.114931 0-7.247725 5.867206-13.114931 13.11493-13.11493 7.247725 0 13.114931 5.867206 13.114931 13.11493 0 7.247725-5.867206 13.114931-13.114931 13.114931zM185.852376 539.782946h-9.318503v-9.318504c0-0.69026-0.69026-1.380519-1.380519-1.380519h-5.522077c-0.69026 0-1.380519 0.69026-1.380519 1.380519v9.318504h-9.318503c-0.69026 0-1.380519 0.69026-1.380519 1.380519v5.522076c0 0.69026 0.69026 1.380519 1.380519 1.380519h9.318503v9.318504c0 0.69026 0.69026 1.380519 1.380519 1.380519h5.522077c0.69026 0 1.380519-0.69026 1.380519-1.380519v-9.318504H185.852376c0.69026 0 1.380519-0.69026 1.380519-1.380519v-5.522076c0-1.035389-0.69026-1.380519-1.380519-1.380519z m602.596562-240.900573v-7.592855c0-0.69026-0.69026-1.380519-1.380519-1.380519h-11.734412v-11.734412c0-0.69026-0.69026-1.380519-1.380519-1.380519h-7.592854c-0.69026 0-1.380519 0.69026-1.380519 1.380519V289.908999h-11.734412c-0.69026 0-1.380519 0.69026-1.380519 1.380519v7.592855c0 0.69026 0.69026 1.380519 1.380519 1.380519h11.734412v11.734412c0 0.69026 0.69026 1.380519 1.380519 1.380519h7.592854c0.69026 0 1.380519-0.69026 1.380519-1.380519V300.262892h11.734412c1.035389 0 1.380519-0.69026 1.380519-1.380519z" fill="#E77A8C" p-id="5641"></path><path d="M210.356589 349.271318c-13.80519 0-25.194473 11.389282-25.194472 25.539602 0 14.15032 11.389282 25.539602 25.194472 25.539602s25.194473-11.389282 25.194473-25.539602c0-14.15032-11.389282-25.539602-25.194473-25.539602z m0 44.866869c-10.699023 0-19.327267-8.628244-19.327266-19.672397 0-10.699023 8.628244-19.672396 19.327266-19.672396 10.699023 0 19.327267 8.628244 19.327267 19.672396 0 10.699023-8.628244 19.672396-19.327267 19.672397z m272.652511-191.892147c-18.982137 0-34.512976 15.530839-34.512976 34.512976s15.530839 34.512976 34.512976 34.512976 34.512976-15.530839 34.512976-34.512976c-0.34513-18.982137-15.530839-34.512976-34.512976-34.512976z m0 63.158746c-15.875969 0-28.64577-12.769801-28.64577-28.64577 0-15.875969 12.769801-28.64577 28.64577-28.64577 15.875969 0 28.64577 12.769801 28.64577 28.64577-0.34513 15.875969-13.114931 28.64577-28.64577 28.64577z m369.979104 273.6879c-11.044152 0-20.362656 8.973374-20.362656 20.362656s8.973374 20.362656 20.362656 20.362656c11.044152 0 20.362656-8.973374 20.362655-20.362656s-9.318504-20.362656-20.362655-20.362656z m0 34.858106c-7.937984 0-14.49545-6.557465-14.49545-14.49545s6.557465-14.49545 14.49545-14.49545c7.937984 0 14.49545 6.557465 14.49545 14.49545s-6.557465 14.49545-14.49545 14.49545z m-51.079205 15.18571c-11.734412 0-21.398045 9.663633-21.398045 21.398045 0 11.734412 9.663633 21.398045 21.398045 21.398045 11.734412 0 21.398045-9.663633 21.398045-21.398045 0-12.079542-9.663633-21.398045-21.398045-21.398045zM252.46242 400.695652c-8.973374 0-16.221099 7.247725-16.221099 16.221099s7.247725 16.221099 16.221099 16.221099 16.221099-7.247725 16.221099-16.221099-7.247725-16.221099-16.221099-16.221099z" fill="#FFFFFF" p-id="5642"></path><path d="M838.492754 918.390293H157.896866c-1.380519 0-2.415908 1.035389-2.415909 2.415909v9.663633c0 1.380519 1.035389 2.415908 2.415909 2.415908h680.595888c1.380519 0 2.415908-1.035389 2.415908-2.415908v-9.663633c0-1.380519-1.035389-2.415908-2.415908-2.415909z m55.911021 0h-39.344793c-1.380519 0-2.415908 1.035389-2.415908 2.415909v9.663633c0 1.380519 1.035389 2.415908 2.415908 2.415908h39.344793c1.380519 0 2.415908-1.035389 2.415908-2.415908v-9.663633c-0.34513-1.380519-1.380519-2.415908-2.415908-2.415909z m-388.616111 54.530502v-9.663633c0-1.380519-1.035389-2.415908-2.415908-2.415908H228.303337c-1.380519 0-2.415908 1.035389-2.415909 2.415908v9.663633c0 1.380519 1.035389 2.415908 2.415909 2.415909H503.371756c1.380519-0.34513 2.415908-1.380519 2.415908-2.415909z m196.378834 35.203236H356.691608c-1.380519 0-2.415908 1.035389-2.415909 2.415908v9.663634c0 1.380519 1.035389 2.415908 2.415909 2.415908h345.47489c1.380519 0 2.415908-1.035389 2.415908-2.415908v-9.663634c-0.34513-1.380519-1.380519-2.415908-2.415908-2.415908z m88.353219 0h-56.601281c-1.380519 0-2.415908 1.035389-2.415908 2.415908v9.663634c0 1.380519 1.035389 2.415908 2.415908 2.415908h56.601281c1.380519 0 2.415908-1.035389 2.415908-2.415908v-9.663634c0-1.380519-1.035389-2.415908-2.415908-2.415908z m-75.238288-47.282777h-151.857095c-1.380519 0-2.415908 1.035389-2.415908 2.415908v9.663633c0 1.380519 1.035389 2.415908 2.415908 2.415909h151.857095c1.380519 0 2.415908-1.035389 2.415908-2.415909v-9.663633c0-1.380519-1.035389-2.415908-2.415908-2.415908z m-169.458712 14.15032c1.380519 0 2.415908-1.035389 2.415908-2.415908V962.912032c0-1.380519-1.035389-2.415908-2.415908-2.415908H527.530839c-1.380519 0-2.415908 1.035389-2.415908 2.415908v9.663634c0 1.380519 1.035389 2.415908 2.415908 2.415908h18.291878z" fill="#E77A8C" p-id="5643"></path><path d="M789.139198 670.587125s-29.681159-95.600944-114.237951-34.858106c0 0-12.079542 11.389282-13.114931 30.716549 0 0-62.123357 8.283114-39.344793 61.778227h214.325582c0-0.34513 18.637007-50.734075-47.627907-57.63667z" fill="#FFFFFF" p-id="5644"></path><path d="M835.041456 690.259521c-7.937984-12.769801-22.778564-20.362656-44.866869-23.123694-1.380519-4.141557-5.867206-15.185709-14.15032-26.229861-13.460061-18.637007-31.061678-28.64577-50.388945-28.645771-16.566229 0-34.512976 6.902595-53.840243 20.707786 0 0-0.34513 0-0.34513 0.34513-0.34513 0.34513-12.079542 11.389282-14.15032 30.371419-7.592855 1.380519-30.026289 6.902595-40.035052 24.504213-6.212336 11.044152-6.212336 24.849343 0.69026 40.725312 0.34513 1.035389 1.380519 1.725649 2.761038 1.725648h214.325581c1.380519 0 2.415908-0.69026 2.761038-2.070778 0.69026-1.380519 7.937984-21.052915-2.761038-38.309404z m-1.725649 33.822717h-210.184024c-5.176946-13.114931-5.522076-24.504213-0.34513-33.477587 10.008763-17.946748 37.964274-21.743175 37.964274-21.743175 1.380519-0.34513 2.415908-1.380519 2.415908-2.761038 1.035389-16.911358 11.044152-27.265251 12.079542-28.64577 17.946748-12.769801 34.858106-19.327267 50.043815-19.327267 42.450961 0 59.362319 52.114594 59.707449 52.804854 0.34513 1.035389 1.380519 2.070779 2.415908 2.070778 21.052915 2.415908 35.548365 9.318504 42.450961 20.362656 7.592855 12.079542 4.831817 25.884732 3.451297 30.716549z" fill="#E77A8C" p-id="5645"></path><path d="M562.734075 443.146613l25.539602-74.202899-224.334344 30.716549-42.796091 55.220762v246.422649l-32.442197 39.689922 231.236939 42.105831 42.796091-54.185372 126.662622-40.035053v-205.352207z" fill="#FFFFFF" p-id="5646"></path><path d="M691.122346 479.730367l-123.556455-39.344792 24.504213-71.441861c0.34513-1.035389 0-2.070779-0.345129-2.761038-0.69026-0.69026-1.725649-1.035389-2.761038-1.035389l-224.334345 30.716549c-0.69026 0-1.380519 0.34513-2.070778 1.035389l-42.796091 55.220762c0 0.34513-0.34513 0.34513-0.345129 0.690259s-0.34513 0.69026-0.34513 1.035389v245.38726l-32.097068 38.999663c-0.69026 0.69026-0.69026 2.070779-0.34513 2.761038 0.34513 1.035389 1.380519 1.725649 2.070779 1.725649l231.236939 41.760701h0.69026c1.035389 0 1.725649-0.34513 2.415908-1.035389l42.105831-53.495113 125.627233-39.689923c1.380519-0.34513 2.070779-1.380519 2.070779-2.761038v-205.352207c0.34513-1.035389-0.34513-2.070779-1.725649-2.415909z m-130.11392 173.25514l-115.27334-11.734412V493.535558h115.27334v159.449949z m-235.723627-196.378834l235.723627-11.389282v42.105831h-118.034378c-1.380519 0-2.761038 1.380519-2.761038 3.106168v153.237614c0 1.380519 1.035389 2.761038 2.415908 2.761038l118.379508 12.079541v65.574655L325.284799 697.162117v-240.555444z m41.415572-55.220761l218.467138-29.68116-23.123694 67.990563-233.307718 11.044152 37.964274-49.353555z m153.237613 377.226828l-224.679474-40.725312 28.300641-34.858105 234.688237 26.920121-38.309404 48.663296z m167.387934-92.839905l-120.450286 37.964273V446.252781l120.450286 38.309403v201.210651z" fill="#E77A8C" p-id="5647"></path><path d="M466.442872 454.535895c-16.221099-51.424334-77.999326-30.716549-77.999326-30.716549-20.362656-43.14122-53.840243-40.725312-53.840243-40.725312-66.610044 3.106168-57.29154 66.264914-57.29154 66.264914C238.65723 445.217391 234.170543 485.942703 234.170543 485.942703c-20.017526 6.902595-9.318504 26.229862-9.318504 26.229862h218.122009c33.132457-19.327267 23.468824-57.63667 23.468824-57.63667z" fill="#FFFFFF" p-id="5648"></path><path d="M468.16852 452.810246c-9.663633-30.371419-34.167846-36.928884-53.495113-36.928884-11.389282 0-21.398045 2.415908-25.884732 3.451297-21.052915-42.450961-55.220762-40.035052-55.220761-40.035052-21.052915 1.035389-36.928884 7.937984-47.282777 20.707786-13.460061 16.221099-13.460061 36.928884-13.114931 45.211998h-1.725649c-14.84058 0-26.574992 6.902595-34.167847 20.017526-4.141557 7.247725-5.867206 14.49545-6.557465 17.946748-5.522076 2.415908-9.318504 5.867206-11.044152 10.699023-3.451298 8.973374 1.725649 18.637007 2.070778 18.982136 0.69026 1.035389 1.380519 1.380519 2.415909 1.380519h218.122008c0.69026 0 1.035389 0 1.380519-0.345129 34.512976-20.362656 24.504213-60.742838 24.504213-61.087968z m-26.574991 55.565892H226.232558c-1.035389-2.415908-2.761038-7.937984-1.035389-12.424672 1.380519-3.451298 4.486687-6.212336 9.318503-7.937984 1.035389-0.34513 1.725649-1.380519 2.070779-2.415909 0 0 1.035389-8.628244 5.867206-17.601617 7.247725-12.769801 18.637007-18.291877 33.822716-16.911359 1.035389 0 1.725649-0.34513 2.415909-1.035389 0.69026-0.69026 1.035389-1.725649 0.690259-2.415908 0-0.34513-3.451298-25.884732 11.389282-44.17661 9.318504-11.389282 23.813953-17.601618 43.14122-18.291877h0.69026c5.176946 0 32.787327 1.725649 50.043815 38.999663 0.69026 1.380519 2.070779 2.070779 3.451298 1.725649 0 0 12.079542-4.141557 26.574991-4.141557 24.849343 0 41.070442 11.044152 47.627907 32.787327 0.34513 1.380519 8.973374 35.893495-20.707785 53.840243z" fill="#E77A8C" p-id="5649"></path></svg>
                        </div>
                        <div class="none-comment">
                            暂无评论，赶紧来抢沙发吧！
                        </div>
                    </div>
                </div>
                <aside class="view_left">
                    <%= require('html-loader!../../components/elements/leftele/hotart/index.html') %>
                    <%= require('html-loader!../../components/plugin/artnav/index.html') %>
                </aside>
            </div>
        </div>
        <!-- 脚部[[ -->
        <%= require('html-loader!../../components/elements/footer/index.html') %>
        <!-- 脚部]] -->
    </body>
</html>